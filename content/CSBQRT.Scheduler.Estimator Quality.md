---
id: 5tfr5ecoiwmwhl299wn79wp
title: Estimator Quality
desc: ""
updated: 2024-11-25T11:00
created: 2024-11-21T17:40
---
**

## Overview

The csbqrt scheduler is a program that schedules certain parts of the experiments for the cs-bqrt universe. At the moment only certain parts of the experiments are in scope, i.e. small experiments. The estimation mechanism at the moment tries to replicate the assignment mechanism. 

  

We want to understand how 

Effectively, it assigns probabilities for each ad unit (before L1 level, now L2/L3 level) to be assigned to a particular experiment, and then uses this information to schedule the experiments.

  

## Experiments In-Scope 
  

At the moment, the budget abtest batch consists of: 

  

|   |   |
|---|---|
|Full bqrt slots|no|
|Small csbqrt experiment slots|yes|
|Regular csbqrt experiment slots(including clusters and scaled lift)|no|

  
  

## Overall Considerations

At the moment the cs-bqrt scheduler is limited in scope in the following ways:

1. We are unaware of effective/required mde by experimenters ([Sergei Leonenkov](mailto:leonenkov@meta.com) mentioned ‘nobody complained about traffic)
    
2. Not in place for regular experiments- they just get scheduled and get whatever traffic they get
    
3. At reclustering/user reshuffle times (are they always the same, or not quite), clusters appear ansd the estimator doesnt know about them. Cluster creation lifecycle misaligned with the scheduler/estimator lifecycle.
    

  
  

At the moment this is not a consideration, as all small experiments have higher priority than all others.

  
  

##  Estimator Quality Computation

  

Use categorical cross- entropy for all adunits, present in both the last scheduler estimation run on Thursday/Friday (cs_bqrt_estimator_eligibility_results), and the assignment data (csbqrt_experiment_id_assignment) on Tuesday. If an experiment is not a small experiment (how to find out ?), assign to a dummy experiment.

  

Perhaps use normalized entropy for the ‘move to l2/l3 based assignment’ part, in order to account for different dataset size?

In the sestimator table, we  data about advertiser units, experiments, and probability and in the assignment table we have data about the assignment. Then we could calculate the ROC curve and the area under it when we check Friday for the estimator and Tuesday data for the assignment limit only to the advertiser units which appear in both places.



 structure of cs_bqrt_estimator_eligibility_results_l2_l3_ts_signal:
| Column                    | Type    | Description                                                                                   |

| Column                    | Type    | Description                                                                                   |
|---------------------------|---------|-----------------------------------------------------------------------------------------------|
| ds                        | string  | Datestamp in YYYY-MM-DD format                                                                 |
| ts                        | string  | Timestamp                                                                                      |
| ad_id                     | bigint  | ad_id                                                                                          |
| experiment_id             | bigint  | Experiment ID                                                                                  |
| segment_requested_pct     | double  | Percentage of segments of this ad (seg/50) requested for the experiment [Generated by Metamate]|
| segments_consumed_pct     | double  | Percentage of segments for this ad that would be allocated to the experiment if it's scheduled (will be <= the requested)|
| is_allocated              | boolean | Is the experiment allocated, or is it a candidate experiment                                   |
| latest_scheduler_request_id| bigint | The request ID of the scheduler these estimates belong to                                      |
| grouping_level            | string  | l2 non-cbo, or l3 cboto                                                                        |
 

 * cs_bqrt_estimator_eligibility_results_ts_signal
 
 has the following structure

| Column                     | Type                | Description                                                                                   |
|----------------------------|---------------------|-----------------------------------------------------------------------------------------------|
| ds                         | string              | Datestamp in YYYY-MM-DD format                                                                 |
| ts                         | string              | Timestamp                                                                                      |
| grouping_level             | string              | Indicates decision grouping: L2/L3                                                             |
| group_id                   | bigint              | Campaign or campaign group ID depending on grouping level                                      |
| assignment_source          | string              | Type of AdPublisher deployment the assignment is coming from. E.g. dev, staging, canary or prod.|
| qrt_universe               | string              | QRT universe name                                                                              |
| experiment_id              | bigint              | CS experiment ID chosen for assignment.                                                        |
| assignment_index           | bigint              | Index used for force reassignments manually if needed.                                         |
| canary_id                  | string              | Self explanatory                                                                               |
| experiment_to_segment_count| map<bigint,bigint>  | Map of eligible deterministic experiment to number of segments allocated                       |
| batch_id                   | bigint              | FBID of Batch                                                                                  |
| assignment_reason          | string              | How we got this assignment.                                                                    |
| previous_exp_id            | bigint              | The experiment the ad was assigned in a previous run                                           |
**


# another way to calculate this:

use data from 
cs_bqrt_estimator_results_fast

| Column           | Type    | Description                                                                 |
|------------------|---------|-----------------------------------------------------------------------------|
| ds               | string  | Datestamp in YYYY-MM-DD format                                               |
| ts               | string  | Datestamp in YYYY-MM-DD format                                               |
| request_id       | bigint  | Latest Scheduler Request ID (to be deprecated)                               |
| experiment_id    | bigint  | CSBQRT Experiment ID                                                         |
| eligible_count   | bigint  | Total number of Ad Units eligible for the experiment                         |
| fulfillable_count| bigint  | Total number of eligible Ad Units that have enough segments for the experiment with the current arrangement of the batch |

and csbqrt_experiment_id_assignment. this time compare the ratio 
fulfillable_count/eligible_count to the ratio of eligible vs assigned adunits in the assignment table.
here is a snippet how you can find eligible adunits in the assignment table:

```sql
with units as(
           SELECT
            ad_id,
            ad_buying_type,
            ad_optimization_goal,
            ad_conversion_type,
            custom_bqrt_flag_set,
            pixel_id,
            app_id,
            account_id,
            grouping_level,
            assign.group_id AS group_id

        WHERE
            assign.grouping_level = 'L2'
            AND assign.assignment_source = 'prod'
            AND assign.experiment_id > -1

        UNION ALL

        SELECT
            ad_id,
            ad_buying_type,
            ad_optimization_goal,
            ad_conversion_type,
            custom_bqrt_flag_set,
            pixel_id,
            app_id,
            account_id,
            deterministic_experiment_to_segments,
            grouping_level,
            assign.group_id AS group_id
        FROM {ad_units_source} signal
        JOIN
            {assignment_data_source} assign
            ON assign.group_id = signal.campaign_group_id
        WHERE
            assign.grouping_level = 'L3'
            AND assign.assignment_source = 'prod'
            AND assign.experiment_id > -1
)

SELECT
            experiment_id,
            units.grouping_level,

            units.ad_id,

        FROM units
        JOIN experiments
            ON (
                -- matching rules
                (
                    CARDINALITY(experiments.buying_types) = 0
                    OR CONTAINS(experiments.buying_types, units.ad_buying_type)
                )
                AND (
                    CARDINALITY(experiments.optimization_goals) = 0
                    OR CONTAINS(
                        experiments.optimization_goals,
                        units.ad_optimization_goal
                    )
                )
                AND (
                    CARDINALITY(experiments.conversion_types) = 0
                    OR CONTAINS(
                        experiments.conversion_types,
                        units.ad_conversion_type
                    )
                )
                AND (
                    CARDINALITY(experiments.custom_flags) = 0
                    OR CARDINALITY(
                        ARRAY_INTERSECT(
                            experiments.custom_flags,
                            units.custom_bqrt_flag_set
                        )
                    ) > 0
                )
                AND (
                    experiments.manual_pixel_ids IS NULL
                    OR CONTAINS(experiments.manual_pixel_ids, units.pixel_id)
                )
                AND (
                    experiments.manual_app_ids IS NULL
                    OR CONTAINS(experiments.manual_app_ids, units.app_id)
                )
                AND (
                    experiments.manual_account_ids IS NULL
                    OR CONTAINS(experiments.manual_account_ids, units.account_id)
                )
            )
 
            )
```







#  prompt for proportion- based estimator quality

I want to cobble together a query which looks at advertiser units which are assigned to experiments and how many of the ad units which were eligible for a given experiment and assigned somewhere, I'll give you the query later, are actually assigned to the experiment and then compare this to a table where we predict similar proportions and then finally compare the proportions. So let me give you the list of things you should know. First of all, the ad units live in this table.
csbqrt_experiment_id_assignment (ds = '2024-11-19')).
the predictions livasrte in this table:
cs_bqrt_estimator_results_fast (ds = '2024-11-15', ts= '2024-11-15 ''').
| Column           | Type    | Description                                                                 |
|------------------|---------|-----------------------------------------------------------------------------|
| ds               | string  | Datestamp in YYYY-MM-DD format                                               |
| ts               | string  | Datestamp in YYYY-MM-DD format                                               |
| request_id       | bigint  | Latest Scheduler Request ID (to be deprecated)                               |
| experiment_id    | bigint  | CSBQRT Experiment ID                                                         |
| eligible_count   | bigint  | Total number of Ad Units eligible for the experiment                         |
| fulfillable_count| bigint  | Total number of eligible Ad Units that have enough segments for the experiment with the current arrangement of the batch |

need the ratio fulfillable_count/eligible_count.

take the unique experiment_ids from the 
cs_bqrt_estimator_results_fast table and then also find their properties by joining with the:
raw_abqrt_experiments table. it also has a ds- make sure to remove duplicates.
it should be something like this:

```sql 
   SELECT
                experiment_id,
                buying_types,
                optimization_goals,
                conversion_types,
                custom_flags,
                segments,
            FROM (
                select distinct experiment_id
                from cdb.qrt_budget.cs_bqrt_estimator_results_fast
                where ds = '2024-11-15' and ts = '2024-11-15 08:00:99'
            ) a
            JOIN raw_abqrt_experiments on a.experiment_id= experiments.experiment_id
```

then in order to match with the eligible ad units, you can use the following 2 tables:
csbqrt_assignments_ad_id_snapshot_fast_ts_signal
relevant columns:

Column	Type	Description
[ds] string Date in format YYYY-mm-DD [Generated by Metamate]
[ts] string Timestamp [Generated by Metamate]
batch_id bigint bqrt batch id, for which the assignments are made
ad_id bigint adunit_id (l1 for now)
experiment_id bigint  identifies experiment assigned to the ad (csbqrt, so asbqrt universe)]
(make sure to dedup and make sure experiment_id>0)


and then bqrt_traffic_measurable_adunits_fast
| Column                | Type        | Description                                                                 |
|-----------------------|-------------|-----------------------------------------------------------------------------|
| ds                    | string      | Date in format YYYY-mm-DD [Generated by Metamate]                           |
| shard                 | string      | Shard                                                                       |
| ts                    | string      | Timestamp [Generated by Metamate]                                           |
| db_id                 | int         | AdPublisher's DB ID                                                         |
| ad_id                 | bigint      | AdUnit Id                                                                   |
| ad_buying_type        | int         | adBuyingType                                                                |
| ad_optimization_goal  | int         | adOptimizationGoal                                                          |
| ad_conversion_type    | int         | adConversionType                                                            |
| custom_bqrt_flag_set  | array<int>  | AdSetCustomBqrtFlagSet                                                      |
| pixel_exp_id_set      | array<int>  | Eligible CSBQRT ExperimentIDs if the AdUnit has a PixelID                   |
| app_exp_id_set        | array<int>  | Eligible CSBQRT ExperimentIDs if the AdUnit has a AppID                     |
| account_exp_id_set    | array<int>  | Eligible CSBQRT ExperimentIDs if the AdUnit has a AccountID                 |
| campaign_id           | bigint      | Campaign Id                                                                 |
| campaign_group_id     | bigint      | Campaign Group Id                                                           |
| pixel_id              | bigint      | Pixel Id                                                                    |
| app_id                | bigint      | App Id                                                                      |
| account_id            | bigint      | Account Id                                                                  |
| advertiser_country    | int         | Advertiser country id as per https://fburl.com/code/7s8hvywc. Used for Clustered CS-BQRT experiment intentions definition |
| is_hec_ad             | boolean     | [deprecated] Is HEC ad                                                      |
| is_hec_ad2            | int         | Indicates whether the advertisement is part of the HEC (High Engagement Campaign) category |


you can join these as follows (after doing the proper filtering and related placeholders):

```sql
   SELECT
            ad_id,
            ad_buying_type,
            ad_optimization_goal,
            ad_conversion_type,
            custom_bqrt_flag_set,
            pixel_id,
            app_id,
            account_id,
            experiment_id
        FROM ({ad_units_source})
        JOIN ({assignment_data_source})
            USING (ad_id)
```
finally, you can use the matching rules fragment to join units and experiments:

```

SELECT
            experiment_id,
            units.grouping_level,

            units.ad_id,

        FROM units
        JOIN experiments
            ON (
                -- matching rules
                (
                    CARDINALITY(experiments.buying_types) = 0
                    OR CONTAINS(experiments.buying_types, units.ad_buying_type)
                )
                AND (
                    CARDINALITY(experiments.optimization_goals) = 0
                    OR CONTAINS(
                        experiments.optimization_goals,
                        units.ad_optimization_goal
                    )
                )
                AND (
                    CARDINALITY(experiments.conversion_types) = 0
                    OR CONTAINS(
                        experiments.conversion_types,
                        units.ad_conversion_type
                    )
                )
                AND (
                    CARDINALITY(experiments.custom_flags) = 0
                    OR CARDINALITY(
                        ARRAY_INTERSECT(
                            experiments.custom_flags,
                            units.custom_bqrt_flag_set
                        )
                    ) > 0
                )
                AND (
                    experiments.manual_pixel_ids IS NULL
                    OR CONTAINS(experiments.manual_pixel_ids, units.pixel_id)
                )
                AND (
                    experiments.manual_app_ids IS NULL
                    OR CONTAINS(experiments.manual_app_ids, units.app_id)
                )
                AND (
                    experiments.manual_account_ids IS NULL
                    OR CONTAINS(experiments.manual_account_ids, units.account_id)
                )
            )
 
            )
```
and see what matches with what. Then aggregate this, carrying over the 'experiment_id' from the units table, and then
compute a production ration about how many adunits were eligible and then received.

please create the subqueries one by one, so I can debug then easier, one subquery building on the previous ones.

